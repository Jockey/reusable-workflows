name: Build Docker Image with Args

on:
  workflow_call:
    inputs:
      docker_registry:
        description: "The Docker Registry to use"
        required: true
        type: string
      docker_image_name:
        description: "The Docker Container Name to use."
        required: true
        type: string
      #
      docker_file_name:
        description: "The Dockerfile filename to use, relative to the repo root."
        required: false
        type: string
        default: "Dockerfile"
      #
      deploy_environment:
        description: "The Deploy Environment that should be passed to Docker during Build Phase. If not provided, it will be automagically determined based on branch name."
        required: false
        type: string
        default: ""
      build_id:
        description: "The Build ID that should be passed to Docker during Build Phase."
        required: true
        type: string
    outputs:
      tagless_image_url: 
        description: "The \"tagless\" Docker image URL. So would be \"{docker_registry}{docker_image_name}:{deploy_environment}\""
        value: ${{ jobs.build_and_publish.outputs.tagless_image_url }}
      tagged_image_url: 
        description: "The \"full\" Docker image URL. So would be \"{docker_registry}{docker_image_name}:{deploy_environment}-{build_id}\""
        value: ${{ jobs.build_and_publish.outputs.tagless_image_url }}
    secrets:
      DOCKER_REGISTRY_USERNAME:
        required: true
      DOCKER_REGISTRY_PASSWORD:
        required: true

env:
  DOCKER_BUILDKIT: 1

jobs:
  build_and_publish:
    name: Docker Build & Publish
    runs-on: ubuntu-latest
    outputs:
      tagless_image_url: ${{ steps.build_strs.outputs.tagless_img_url }}
      tagged_image_url: ${{ steps.build_strs.outputs.tagged_img_name }}
    steps:
      # This checks out the repository so your workflow operates from root of repository
      - uses: actions/checkout@v4

      - name: Generate Build Strings
        id: build_strs
        run: |
          lowercase_env=$(echo "${{ inputs.deploy_environment }}" | tr '[:upper:]' '[:lower:]')
          echo "lowercase_env=${lowercase_env}" >> $GITHUB_OUTPUT
          tagless_image_base=$(echo "${{ inputs.docker_registry }}${{ inputs.docker_image_name }}:${lowercase_env}")
          echo "tagless_img_url=$(echo ${tagless_image_base})" >> $GITHUB_OUTPUT
          echo "cache_image_ref=$(echo ${tagless_image_base}-buildcache)" >> $GITHUB_OUTPUT
          echo "tagged_img_name=$(echo ${tagless_image_base}-${{ inputs.build_id }})" >> $GITHUB_OUTPUT

      - name: Print Deploy ifno
        run: |
          echo "Building ${{ steps.build_strs.outputs.tagged_img_name }}"
          echo "Using ${{ steps.build_strs.outputs.cache_image_ref }} as Build Cache"

      - name: Login to Docker Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ inputs.docker_registry }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build & Push Image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ${{ inputs.docker_file_name }}
          push: true
          cache-from: type=registry,ref=${{ steps.build_strs.outputs.cache_image_ref }}
          cache-to: type=registry,mode=min,ref=${{ steps.build_strs.outputs.cache_image_ref }}
          tags: ${{ steps.build_strs.outputs.tagged_img_name }}
          build-args: |
            DEPLOY_ENV=${{ inputs.deploy_environment }} # DEPLOY_ENV may be required by the build script
            BUILD_ID=${{ inputs.build_id }}
